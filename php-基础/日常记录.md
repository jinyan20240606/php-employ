

# 记录

> 类似github：https://github.com/Forece/notes/tree/34e695d1439052831ab329743fbf87bb307233bb

## 日常记录

1. 不同编码在打字时有不同吗，都能输入中文英文吗？
   1. 在现代操作系统和输入法中，无论你使用的是 UTF-8、GBK、GB2312、还是其他编码，你都可以正常输入中文和英文。
   2. 编码主要影响的是字符的存储和传输方式，而不是输入方式本身
      1. 编码是将字符（比如“你”、“a”、“❤”）转换成二进制数据（也就是字节）的过程。不同的编码方式决定了：一个字符占用多少字节，一个字符对应的二进制值是多少
      2. 当你用搜狗输入法、微软拼音、谷歌输入法等输入“你好”，输入法会以 Unicode 的方式传递给应用程序（如 Word、VSCode、浏览器）。应用程序再根据文件或系统的编码设置，将这些字符保存为对应编码的字节
2. php的写法
   1. php+html混合写法：小型网站、快速开发
      1. 如可以单文件中同时处理前后端逻辑，也可以类似于模板引擎的感觉
   2. 纯 PHP 输出 HTML：动态内容生成
   3. API接口开发等：前后端分离
   4. MVC等：中大型项目
   5. 面向对象 + 类库：通用功能封装
3. 常量定义define和const和变量区别：
   1. const。
      1. 使用 const 定义的常量遵循当前所在的命名空间规则。如果你在某个命名空间内定义了一个常量，那么这个常量将属于那个命名空间
      2. 静态性：const 定义的常量是编译时常量，意味着它们必须在编译阶段就已经确定下来，不能依赖于运行时的条件。
      3. 位置限制：const 只能在顶层作用域或者类中使用。它不能在函数、方法或控制结构（如 if 语句）内部使用
   2. define
      1. 命名空间：使用 define() 定义的常量是全局的，即使是在一个命名空间中定义的，也不会自动带有该命名空间前缀。不过，你可以通过传递完整的名字（包括命名空间）来定义特定命名空间下的常量
      2. 灵活性：可以在类外部、函数内部、条件语句等动态上下文中使用 define() 来定义常量
      3. 编译时与运行时：define() 是在运行时定义常量，这意味着你可以在逻辑判断后决定是否定义一个常量
   3. 常量7.0以前是不支持定义数组的。之前只能是基本类型
   4. 变量：不需要事先声明，可以直接赋值使用`$name = "张三";`
      1. 变量名区分大小写
      2. 变量名必须以 $ 开头
      3. 变量名只能包含字母、数字和下划线
      4. 变量名不能以数字开头

4. 全局变量和常量不会被销毁
5. htmlcss里面：在HTML后缀文件中路径要使用绝对路径，从根目录开始匹配，在CSS后缀文件中页面图片的路径要使用相对路径，相对于当前页面本身。
   1. 假如css写在了html中内联样式，那也是看所在文件后缀，
6. MVC设计模式中
   1. 一般每个页面都对应一个控制器文件类处理，页面的不同操作对应不同Action
   2. 控制器的每个方法就是一个接口
7. 同步和异步的理解
   1. 同步：就是你讲我听，两个人之间必定是同步
   2. 异步：你讲我听的同时，突然步调不一致，一定是存在一个第三者，在其他时间帮我将我的步调同步给你
8. 所有能将内容写入 PHP 输出流的操作，最终都会发送到浏览器（或先进入 OB 缓存再发送）。常见方式包括：
   1. 输出函数：print、print_r()、printf()、var_dump() 等；
   2. 文件包含：include/require 含有输出的文件；
   3. 直接编写 HTML 代码（在 PHP 标签外）；
   4. 缓存释放函数：ob_end_flush() 等；
   5. 文件输出函数：readfile()、fpassthru() 等。

### 多进程多线程

1. 形象比喻：CPU 核心 = 一个厨师，线程 = 一道菜，4 个厨师（4 核）可以 同时做 4 道菜（并行），如果有 8 道菜，每个厨师就要轮流做两道（并发），总时间更长

8. Swoole是异步非阻塞多进程多线程的http服务器，nodejs是异步非阻塞单进程单线程的http服务器
   1. nodejs默认初衷是单进程，但是后面引入了cluster和worker_threads模块提供了多进程多线程能力
9.  进程和线程概念巩固：
   1. 进程：一个正在运行的程序实例。每个进程都有独立的内存空间，包括代码段、数据段、堆栈以及系统资源（如打开的文件、网络连接等）。进程是操作系统进行资源分配和调度的基本单位
   2. 线程：线程是进程内部的一个执行路径或执行单元。一个进程可以包含多个线程，这些线程共享进程的内存空间及资源。线程是CPU调度和分派的基本单位，每个进程可以独立分配cpu核心
      1. 多线程之间有线程安全问题：容易出现竞态条件，死锁问题
   3. 多进程
      1.  CPU 密集型任务（并行计算）
      2.  高容错性系统
      3.  需要资源隔离的场景
      4.  跨语言或跨环境调用：进程间可通过标准输入输出通信，适合调用 Python、Node.js 等其他语言程序
   4. 多线程
      1. I/O 密集型任务（高并发）：Web 服务器、数据库连接池、网络爬虫中 线程在等待 I/O（如数据库、网络）时cpu可以调度切换到另个线程，提高吞吐量
      2. 需要频繁共享数据的场景：缓存系统、实时仪表盘，多个线程可以直接读写同一块内存（如全局变量、缓存对象）
      3. 低延迟响应系统：线程切换比进程切换快，适合对延迟敏感的应用，适合高频交易系统、实时聊天服务器
      4. GUI界面：主线程处理界面，子线程处理后台任务（如下载、计算），避免界面卡顿

#### nodejs中多线程
1. 处理 CPU 密集任务的优势：
   1. 避免阻塞主线程：工作线程独立运行，主线程可继续处理 I/O 任务（如接收请求、读写文件）。
   2. 内存效率较高：工作线程与主线程共享部分内存（如 SharedArrayBuffer 可共享数据），比多进程更节省内存。
   3. 轻量切换：线程创建和销毁的开销比进程小，适合短期、频繁的 CPU 任务。
   4. 局限性（为什么不是最优）：
      1. V8 引擎限制：每个工作线程仍需一个独立的 V8 实例（虽然比进程轻量），创建过多线程会消耗大量内存。
      2. 通信开销：线程间数据传递需通过序列化 / 反序列化（postMessage），大数据传输会有性能损耗（即使共享内存，也需处理同步问题）。
      3. 不适合超重型任务：若任务需要长时间占用 CPU（如持续的视频编码），多线程的性能不如多进程（受限于单进程内存和 V8 限制）


## 包积累

1. ab：http服务器的压力测试包，需安装httpd-tools中包含
2. packagist.org: 查看php相关的所有社区包


## 任何语言的套路

学任何语法的套路：变量常量运算符判断循环函数都是绕不开的（如模板引擎，js，数据库等）

## 框架

1. 在 ThinkPHP 中，数据模型（Model）的查询结果类型根据查询方法的不同而有所区别，常见的有以下几种：
   1. 对象类型：使用 find() 方法查询单条数据时，返回的是模型对象（如 App\Model\User 实例）。
   2. 集合类型：使用 select() 方法查询多条数据时，返回的是 think\model\Collection 集合对象（本质是一个迭代器兼容各种类型）。
      1. 集合类型是个对象类型,含迭代器处理的.`类似结构{items:Array,...}`
      2. 含丰富的api,当成数组遍历当成对象
   3. 数组类型：如果使用 findOrEmpty()、select()->toArray() 或配置了模型的 resultSetType 为数组，则返回数组或关联数组

## 原理

1. PHP-FPM:  待补充

## 基础

1. 0 == null == false  双等的，都是转换为false
2. 三元运算符简写：`$variable = $value ?: $default;` ( 包括 null、空字符串、0、false、空数组等)，就赋值 $default。
   1. php中的||是逻辑运算符，并不能返回默认值，只返回true或false，与js逻辑不一样 
3. php中没有js的花括号对象那种形式,对象数据类型必须是new出来的,一般数组类型最常用
4. 表单数据 (application/x-www-form-urlencoded 和 multipart/form-data)：这类数据通常包含键值对，非常适合用$_POST这样的数组来表示。
   1. JSON 数据 (application/json)：JSON可以表示更复杂的数据结构，如嵌套的对象和数组，而不仅仅是简单的键值对。因此，直接将JSON数据映射到$_POST这样的简单键值对结构并不总是合适的
5. file_get_contents：从某个资源中读取内容不限于本地文件（不仅能读取本地文件，还能远程url，php的流）
   1. 远程url：直接获取远程资源内容
   2. php的流: PHP 提供了很多以 php:// 开头的“伪协议”，它们都不是真实文件，但都可以用 file_get_contents() 读
      1. php://input：读取请求体原始数据
      2. php://stdout：写入标准输出相当于echo
      3. php://stderr：写入错误输出
      4. php://memory： 在内存中读写数据
      5. php://temp：临时文件流，在内存中创建临时文件，而不是直接写入磁盘，这在脚本执行完临时文件会自动删除

### 常用方法

```php
// 1、首字母大写，
ucwords('bootstrap');
// 首字母小写
lcfirst('Bootstrap');
// 全部大写
strtoupper('bootstrap');
// 全部小写
strtolower('BOOTSTRAP');
// 动态调用方法或类的静态方法：当方法名是动态获取的，编码时并不知道
call_user_func($callback, $param1, $param2, ...);
call_user_func([$class, 'getCurrentPage'], $config['var_page']);
```

1. stream_socket_client： 是 PHP 原生的底层 TCP/UDP 客户端函数位于传输层，它可以用来建立与 WebSocket 服务器的原始 TCP 连接，但不能直接与websocket通信
   1. 因为 WebSocket 是一种（在 TCP 之上，位于应用层），你必须手动实现 WebSocket 握手协议和帧（frame）解析，否则服务器不会识别你的消息
   2. stream_socket_client可以连接任何基于 TCP 的服务，包括 WebSocket 服务器，只是链接并不等于通信
2. 在 PHP 中，set_time_limit(int $seconds): bool： 函数用于设置脚本的最大执行时间，防止脚本因长时间运行而占用过多服务器资源，$seconds 为 0 表示无时间限制



### 代码注意点

#### foreach循环引用问题

```php 
$list = [100, 200, 300];

foreach ($list as $k => $v) {
    $v = $v * 2;
}
print_r($list); // 输出仍然是 [100, 200, 300]，没有变化
原因：$v 是当前数组元素的副本（不是引用）。修改 $v 不会影响原数组

// 改进：加&或者直接修改原数组
foreach ($list as $k => &$v) {
    $v = $v * 2;
    // 或者不加 & ，直接修改 $list[$k]= &v*2
}
print_r($list); // 输出 [200, 400, 600]
// 加了&的$v 是当前元素的地址引用。修改 $v 会直接影响原数组
```

#### 反斜杠问题

```php
$class = false !== strpos($config['type'], '\\') 
    ? $config['type'] 
    : '\\think\\paginator\\driver\\' . ucwords($config['type']);
// 1. PHPdai代码字符串中反斜杠要写2个，避免转义，实际匹配的是单斜杠
```

#### 双引号单引号问题

双引号 vs 单引号：关键区别
```php
特性	   双引号 "..."	           单引号 '...'
变量解析	✅ 支持："Hello $name"	❌ 不支持：'Hello $name' 输出就是字面量
转义字符	✅ 支持：\n, \t, \" 等	⚠️ 仅支持 \' 和 \\
性能	   稍慢（需解析）	           稍快（原样输出）
```